# PHP — Object-Oriented Programming (OOP)


---

## 1. Basic Concepts

| Concept | Description | Real-World Example |
|----------|--------------|--------------------|
| **Class** | Blueprint/template for creating objects. | Car Design Blueprint |
| **Object** | Instance of a class. | Actual Car built from the design |
| **Property** | Variable inside a class. | Car color, model, engine type |
| **Method** | Function inside a class. | Start engine, apply brake |
| **Visibility** | Access control — `public`, `protected`, `private`. | Car dashboard (public), engine internals (private) |
| **Constructor** | Initializes object when created. | Car assembly when built |
| **Destructor** | Cleanup when object destroyed. | Car recycling when scrapped |

**Example:**
```php
class Car {
    public string $brand;
    public string $color;

    public function __construct(string $brand, string $color) {
        $this->brand = $brand;
        $this->color = $color;
    }

    public function start(): void {
        echo "{$this->brand} car started!\n";
    }
}

$myCar = new Car('Toyota', 'Red');
$myCar->start(); // Toyota car started!
```

---

## 2. Visibility & Access

Visibility defines how class members can be accessed.

```php
class BankAccount {
    public string $owner;
    private float $balance = 0;

    public function __construct(string $owner) {
        $this->owner = $owner;
    }

    public function deposit(float $amount): void {
        $this->balance += $amount;
    }

    public function getBalance(): float {
        return $this->balance;
    }
}

$acc = new BankAccount('Alice');
$acc->deposit(500);
echo $acc->getBalance(); // 500
```

**Analogy:** In a real bank account, you can deposit or withdraw (public methods), but you can’t directly modify the internal balance (private property).

---

## 3. Static Members & Methods

Used for utilities or data common to all instances.

```php
class MathUtil {
    public static int $count = 0;

    public static function square(int $x): int {
        self::$count++;
        return $x * $x;
    }
}

echo MathUtil::square(5); // 25
echo MathUtil::$count; // 1
```

**Analogy:** Like a calculator’s “square” button — you don’t need to create a calculator each time; you just press the button.

---

## 4. Inheritance

Inheritance allows a subclass to reuse and extend functionality of a parent class.

```php
class Vehicle {
    public function move() { echo "Vehicle moving...\n"; }
}

class Car extends Vehicle {
    public function move() { echo "Car driving on road...\n"; }
}

$car = new Car();
$car->move(); // Car driving on road...
```

**Analogy:** Car inherits common vehicle behavior (movement) but customizes it for driving.

---

## 5. Abstract Classes & Interfaces

**Abstract class:** can have abstract and concrete methods.
**Interface:** defines only method signatures — ensures common behavior.

```php
interface PaymentGateway {
    public function pay(float $amount): void;
}

abstract class OnlinePayment implements PaymentGateway {
    public function showInvoice(float $amount): void {
        echo "Invoice generated for $$amount.\n";
    }
}

class PayPalPayment extends OnlinePayment {
    public function pay(float $amount): void {
        echo "Paid $$amount using PayPal.\n";
    }
}

$payment = new PayPalPayment();
$payment->showInvoice(100);
$payment->pay(100);
```

**Analogy:** Think of `PaymentGateway` as a contract that all payment systems (PayPal, Stripe, etc.) must follow.

---

## 6. Traits

Used to share reusable code among classes.

```php
trait Logger {
    public function log(string $msg): void {
        echo date('H:i:s') . " - $msg\n";
    }
}

class Order {
    use Logger;

    public function place(): void {
        $this->log('Order placed successfully');
    }
}

$order = new Order();
$order->place();
```

**Analogy:** Like a toolkit shared by multiple workers (classes) — each can use the same tools (methods).

---

## 7. Magic Methods

Special built-in methods for custom behaviors.

```php
class Product {
    private array $data = [];

    public function __set($name, $value) {
        $this->data[$name] = $value;
    }

    public function __get($name) {
        return $this->data[$name] ?? null;
    }

    public function __toString(): string {
        return json_encode($this->data);
    }
}

$p = new Product();
$p->name = 'Laptop';
$p->price = 1200;
echo $p; // {"name":"Laptop","price":1200}
```

**Analogy:** Like a smart storage box that automatically stores and retrieves items without you opening it manually.

---

## 8. Namespaces & Autoloading

Organize code and prevent naming conflicts.

```php
namespace App\Models;

class User {
    public function __construct(public string $name) {}
}
```

Used as:
```php
use App\Models\User;

$user = new User('Alice');
echo $user->name;
```

**Analogy:** Think of namespaces like folders — two files named `User.php` can exist in different folders without conflict.

---

## 9. Late Static Binding

Ensures correct class context for inherited static methods.

```php
class Animal {
    public static function create(): static {
        return new static();
    }
}

class Dog extends Animal {}

$dog = Dog::create(); // instance of Dog
```

**Analogy:** When cloning an animal species, you want the new animal to be of the same species — not the base animal.

---

## 10. Composition Over Inheritance

Instead of extending, include required functionality.

```php
class Engine {
    public function start() { echo "Engine starting...\n"; }
}

class Car {
    public function __construct(private Engine $engine) {}

    public function drive() {
        $this->engine->start();
        echo "Car is driving...\n";
    }
}

$car = new Car(new Engine());
$car->drive();
```

**Analogy:** A car *has an* engine — it doesn’t *inherit from* it.

---

## 11. Mini Project — Student Management

```php
interface Person {
    public function getDetails(): string;
}

class Student implements Person {
    public function __construct(
        private string $name,
        private int $rollNo,
        private float $marks
    ) {}

    public function getDetails(): string {
        return "Name: {$this->name}, Roll: {$this->rollNo}, Marks: {$this->marks}";
    }
}

class Teacher implements Person {
    public function __construct(
        private string $name,
        private string $subject
    ) {}

    public function getDetails(): string {
        return "Teacher: {$this->name}, Subject: {$this->subject}";
    }
}

$student = new Student('Ravi', 101, 95.5);
$teacher = new Teacher('Mr. Sharma', 'Math');

echo $student->getDetails() . "\n";
echo $teacher->getDetails();
```

**Analogy:** Both students and teachers share common behavior (provide details), but their details differ — implemented via interface.

---
Thank You

